# Advanced Pattern Examples

JavaScript integration, API-driven setup, conditional logic, and regex selectors.

---

## Onboarding with JS API Setup (onboarding.yml)

Creates a test user via API before running the flow. Demonstrates `onFlowStart`, `runScript`, and passing data from JS to YAML.

```yaml
appId: com.guideline.mobile
jsEngine: graaljs

tags:
  - onboarding
  - portfolio

onFlowStart:
  # Create a new user via API before the flow starts
  - runScript:
      file: ../../utils/createUser.js
      env:
        BASE_URL: "http://localhost:4000"
---
# Use the onboarding link generated by JS
- runFlow:
    file: ./shared/_openOnboardingUrl.yml
    env:
      ONBOARDING_LINK: ${output.onboardingLink}

# Fill out account creation form
- tapOn: Set up account

- tapOn:
    id: text-input-flat
    index: 1

# Inline JS expression for dynamic email
- inputText: ${'personal-'+Date.now()+'@guideline.test'}

# Toggle password visibility
- tapOn:
    id: right-icon-adornment
    index: 0
- tapOn:
    id: right-icon-adornment
    index: 1

# Fill password fields
- tapOn:
    id: text-input-flat
    index: 2
- inputText: password123

- tapOn:
    id: text-input-flat
    index: 3
- inputText: password123

- tapOn:
    id: right-icon-adornment
    index: 0
    label: Hide the keyboard

- tapOn: Accept and Continue

# iOS keychain prompt
- tapOn:
    text: "Not now"
    optional: true

- tapOn: Continue

# Personal information
- tapOn:
    id: text-input-flat
    index: 0
- inputText: 123456789

- tapOn:
    id: right-icon-adornment
    index: 0
    label: Hide the keyboard

- doubleTapOn:
    id: text-input-flat
    index: 1

- eraseText
- inputText: 4801234567

- tapOn:
    id: right-icon-adornment
    index: 0
    label: Hide the keyboard

- scrollUntilVisible:
    element:
      text: "Save and continue"
    direction: "DOWN"
    timeout: 20000

- tapOn: Save and continue

# Walk through the wizard
- tapOn: Skip for now
- tapOn: Get started
- assertVisible: Feel prepared:.*
- tapOn: Continue
- tapOn: Accept & Continue
- assertVisible: Get a portfolio.*
- tapOn: Get started
- tapOn: Continue
- assertVisible: How much do you know about investing?
- tapOn: Continue
- assertVisible: How much risk have you taken with your investments in the past?
- tapOn: Continue
- assertVisible: How much change in your portfolio can you tolerate?
- tapOn: Continue
- assertVisible: How much risk are you comfortable taking?
- tapOn: Continue
- assertVisible: How much would you like your investment to grow over the next 10 years?
- tapOn: Continue
- assertVisible: Review your responses
- tapOn: View your recommendation
- tapOn: Select portfolio

# Verify we landed on the dashboard
- tapOn: Go to my dashboard
- assertVisible: Total retirement savings
```

**Key patterns:**
- `jsEngine: graaljs` — needed for ES6+ syntax in scripts
- `onFlowStart` runs API setup before the flow begins
- `${output.onboardingLink}` passes JS output to a subflow via env
- `${'personal-'+Date.now()+'@guideline.test'}` — inline JS expression in YAML
- `doubleTapOn` to select all text before erasing
- `label: Hide the keyboard` — custom labels make output readable
- `scrollUntilVisible` with timeout for slow-rendering forms
- Regex assertions: `Feel prepared:.*`, `Get a portfolio.*`
- Long wizard flow — each step asserts the correct screen before proceeding

---

## JavaScript API Script (createUser.js)

Full example of a Maestro JS file that creates a user via API with polling.

```javascript
const BASE_URL = "https://my-mobile.guideline.io";

const date = new Date();
const email = `onboarding-${date.getTime()}@guideline.test`;

function createOnboardingUser() {
  const url = `${BASE_URL}/api/v1/genesis/plays.json`;

  const signupResponse = http.post(url, {
    body: JSON.stringify({
      play: "Genesis::Plays::DcParticipants::CreateParticipantWithStatePlay",
      user_email: email,
      custom_title: `${email} - Onboarding test user`,
      state_name: "eligible_invited",
    }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  console.log(`Created user: ${email}`);

  if (!signupResponse.ok) {
    throw new Error(
      `Failed to create user: ${signupResponse.status} - ${signupResponse.body}`
    );
  }

  const data = json(signupResponse.body);
  const executionId = data.execution_id;

  if (!executionId) {
    throw new Error("No execution ID returned from API");
  }

  console.log(`Execution ID: ${executionId}`);
  sleep(10000);

  const user = waitForExecution(executionId);

  if (!user) {
    throw new Error("Failed to get user after execution completed");
  }

  const onboardingLink = `https://my-mobile.guideline.io/participant/onboarding/welcome?context_id=${user.id}&context_type=dc_participant&token=${user.claim_token}`;
  return {
    email: email,
    userId: user.id,
    claimToken: user.claim_token,
    onboardingLink: onboardingLink,
  };
}

function waitForExecution(executionId) {
  const maxWaitTime = 3 * 60 * 1000;
  const pollInterval = 3000;
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitTime) {
    const statusUrl = `${BASE_URL}/api/v1/genesis/executions.json?bust_cache=${Date.now()}`;

    const statusResponse = http.get(statusUrl, {
      headers: {
        "Cache-Control": "no-cache, no-store, must-revalidate",
        Pragma: "no-cache",
        Expires: "0",
      },
    });

    if (!statusResponse.ok) {
      throw new Error(`Failed to check status: ${statusResponse.status}`);
    }

    const executions = json(statusResponse.body);
    const execution = executions.find(exec => exec.id === executionId);

    if (!execution) {
      throw new Error(`Execution ${executionId} not found`);
    }

    if (execution.state === "complete") {
      return getUserByExecutionId(executionId);
    } else if (execution.state === "failed") {
      throw new Error(`Execution failed`);
    }

    sleep(pollInterval);
  }

  throw new Error(`Execution timed out after ${maxWaitTime}ms`);
}

// Busy-wait sleep (no setTimeout in Maestro JS)
function sleep(ms) {
  const start = Date.now();
  while (Date.now() - start < ms) {}
}

// Main execution with error handling
try {
  const result = createOnboardingUser();
  output.user = result;
  output.onboardingLink = result.onboardingLink;
  console.log(`User created: ${result.email}`);
} catch (error) {
  output.error = error.message;
  throw error;
}
```

**Key patterns:**
- `http.post()` / `http.get()` with headers and JSON body
- `json()` to parse responses (not `JSON.parse()`)
- Polling loop with busy-wait `sleep()` function
- Cache-busting via query param: `?bust_cache=${Date.now()}`
- Cache-control headers to prevent stale responses
- `output.onboardingLink` passes result back to the YAML flow
- `try/catch` at top level — `throw` fails the step, `output.error` captures the message
- `console.log()` for debugging (appears in CLI output)

---

## Exporting Shared Functions (api.js)

Export utility functions via `output` for use in subsequent scripts.

```javascript
const BASE_URL = "http://localhost:4000";

function waitForExecution(executionId) {
  const maxWaitTime = 3 * 60 * 1000;
  const pollInterval = 3000;
  const startTime = Date.now();

  while (Date.now() - startTime < maxWaitTime) {
    const statusUrl = `${BASE_URL}/api/v1/genesis/executions.json?bust_cache=${Date.now()}`;
    const statusResponse = http.get(statusUrl, {
      headers: {
        "Cache-Control": "no-cache, no-store, must-revalidate",
        Pragma: "no-cache",
        Expires: "0",
      },
    });

    if (!statusResponse.ok) {
      throw new Error(`Failed to check status: ${statusResponse.status}`);
    }

    const executions = json(statusResponse.body);
    const execution = executions.find(exec => exec.id === executionId);

    if (execution && execution.state === "complete") {
      return getUserByExecutionId(executionId);
    } else if (execution && execution.state === "failed") {
      throw new Error(`Execution failed`);
    }

    sleep(pollInterval);
  }

  throw new Error(`Timed out after ${maxWaitTime}ms`);
}

// Export for other scripts to use
output.api = {
  waitForExecution,
};
```

**Key pattern:** `output.api = { waitForExecution }` makes the function accessible in later scripts.

---

## Conditional Subflow with JS Expression

Uses a JavaScript boolean expression in `when.true` to conditionally run steps.

```yaml
# Suitability check — only shown for some account types
- runFlow:
    when:
      true: ${SHOW_SUITABILITY == true}
    commands:
      - tapOn: View all portfolios
```

**Key pattern:** `when: { true: ${expression} }` evaluates a JS expression. Combine with env vars for feature flags.

---

## Regex Selectors in Action

```yaml
# Match any year in "20XX savings"
- assertVisible:
    text: '20\d{2} savings'

# Match dynamic statement links
- tapOn:
    id: "statement-link-.*"

# Match text with optional suffix
- tapOn: Conservative 45% stocks, 55% bonds( Current)?( Recommended)?

# Match either of two button texts
- tapOn: Keep portfolio|Select portfolio

# Match partial text with any prefix
- tapOn: ".*Authy."
```

**Key patterns:**
- `\d{2}` — digit matching for dynamic years
- `.*` — prefix/suffix wildcard
- `( Current)?` — optional text segments
- `|` — alternation (match either option)
- All `text` and `id` selectors support regex by default

---

## Swipe from Element

```yaml
# Swipe a bottom sheet up by starting from a handle element
- swipe:
    from:
      text: "Bottom sheet handle"
    direction: UP
```

**Key pattern:** `from: { text: ... }` anchors the swipe to a specific element rather than the screen center.

---

## Open Deep Link via Dev Menu

Uses a hidden QA menu to trigger a deep link (useful when `openLink` doesn't work for custom schemes).

```yaml
- runFlow:
    file: ../../../utils/startApp.yml

- tapOn:
    id: gmenu

# Tap repeatedly to reveal hidden menu
- runFlow:
    when:
      notVisible: "Settings"
    commands:
      - repeat:
          times: 9
          commands:
            - tapOn:
                id: gmenu
                retryTapIfNoChange: false
                optional: true

- tapOn: QA
- tapOn: Trigger onboarding workflow
- inputText: ${ONBOARDING_LINK}
- runFlow: ../../../utils/hideKeyboard.yml
- tapOn: Start Onboarding
```

**Key pattern:** When `openLink` doesn't work for your use case, use the app's own QA/dev tools to navigate.
